package template

import (
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"

	"github.com/coffeebeats/gdbuild/internal/action"
	"github.com/coffeebeats/gdbuild/internal/pathutil"
	"github.com/coffeebeats/gdbuild/pkg/godot/compile"
	"github.com/coffeebeats/gdbuild/pkg/godot/platform"
)

/* -------------------------------------------------------------------------- */
/*                                Struct: Build                               */
/* -------------------------------------------------------------------------- */

// Build uniquely specifies a compilation of a Godot export template.
type Build struct {
	// Arch is the CPU architecture of the Godot export template.
	Arch platform.Arch

	// CustomModules is a list of paths to custom modules to include in the
	// template build.
	CustomModules []pathutil.Path `hash:"ignore"` // Ignore; paths are separately hashed.

	// CustomPy is a path to a 'custom.py' file which defines export template
	// build options.
	CustomPy pathutil.Path `hash:"ignore"` // Ignore; path is separately hashed.

	// DoublePrecision enables double floating-point precision.
	DoublePrecision bool

	// Env is a map of environment variables to set during the build step.
	Env map[string]string

	// Godot is the source code specification for the build.
	Godot compile.Godot

	// Optimize is the level of optimization for the Godot export template.
	Optimize compile.Optimize

	// Platform defines which OS/platform to build for.
	Platform platform.OS

	// Profile is the optimization level of the template.
	Profile compile.Profile

	// SCons contains a specification for how to invoke the compiler.
	SCons compile.SCons
}

/* ----------------------------- Function: Name ----------------------------- */

// Name returns the base name of the export template defined by the specified
// parameters.
func Name(pl platform.OS, arch platform.Arch, pr compile.Profile) string {
	name := fmt.Sprintf("godot.%s.%s.%s", pl, pr.TargetName(), arch)
	if pl == platform.OSWindows {
		name += ".exe"
	}

	return name
}

/* ---------------------------- Method: Filename ---------------------------- */

// Filename returns the base name of the export template generated by this
// 'Binary' specification.
func (b *Build) Filename() string {
	return Name(b.Platform, b.Arch, b.Profile)
}

/* -------------------------- Method: SConsCommand -------------------------- */

// SConsCommand returns the 'SCons' command to build the export template.
func (b *Build) SConsCommand(ctx *compile.Context) *action.Process { //nolint:cyclop,funlen
	var cmd action.Process

	cmd.Directory = ctx.Invoke.PathBuild.String()
	cmd.Verbose = ctx.Invoke.Verbose

	scons := b.SCons

	// Define the SCons command, if not yet set.
	if len(scons.Command) == 0 {
		scons.Command = append(scons.Command, "scons")
	}

	// Define the SCons cache path.
	if path := scons.PathCache; path != "" {
		cmd.Environment = append(cmd.Environment, compile.EnvSConsCache+"="+path.String())
	}

	// Add specified environment variables.
	for k, v := range b.Env {
		cmd.Environment = append(cmd.Environment, k+"="+v)
	}

	// Now pass through all environment variables so that these override
	// previously values.
	cmd.Environment = append(cmd.Environment, os.Environ()...)

	// Set the SCons cache size limit, if one was set.
	if csl := scons.CacheSizeLimit; csl != nil {
		cmd.Environment = append(
			cmd.Environment,
			fmt.Sprintf("%s=%d", compile.EnvSConsCacheSizeLimit, *csl),
		)
	}

	// Build the SCons command/argument list.
	var args []string

	// Add multi-core support.
	args = append(args, "-j"+strconv.Itoa(runtime.NumCPU()))

	// Specify the 'platform' argument.
	args = append(args, b.Platform.String())

	// Add the achitecture setting (note that this requires the 'platform.Arch'
	// values to match what SCons expects).
	args = append(args, "arch="+b.Arch.String())

	// Specify which target to build.
	args = append(args, "target="+ctx.Profile.TargetName())

	// Add stricter warning handling.
	args = append(args, "warnings=extra", "werror=yes")

	// Handle a verbose flag.
	if ctx.Invoke.Verbose {
		args = append(args, "verbose=yes")
	}

	// Append 'custom_modules' argument.
	if len(b.CustomModules) > 0 {
		modules := make([]string, len(b.CustomModules))
		for i, m := range b.CustomModules {
			modules[i] = m.String()
		}

		args = append(args, fmt.Sprintf(`custom_modules="%s"`, strings.Join(modules, ",")))
	}

	// Append the 'precision' argument.
	if b.DoublePrecision {
		args = append(args, "precision=double")
	}

	// Append profile/optimization-related arguments.
	switch ctx.Profile {
	case compile.ProfileRelease:
		optimize := compile.OptimizeSpeed
		if b.Optimize != compile.OptimizeUnknown {
			optimize = b.Optimize
		}

		args = append(
			args,
			"production=yes",
			fmt.Sprintf("optimize=%s", optimize),
		)

	case compile.ProfileReleaseDebug:
		optimize := compile.OptimizeSpeedTrace
		if b.Optimize != compile.OptimizeUnknown {
			optimize = b.Optimize
		}

		args = append(
			args,
			"debug_symbols=yes",
			"dev_mode=yes",
			fmt.Sprintf("optimize=%s", optimize),
		)
	default: // ProfileDebug
		optimize := compile.OptimizeDebug
		if b.Optimize != compile.OptimizeUnknown {
			optimize = b.Optimize
		}

		args = append(
			args,
			"debug_symbols=yes",
			"dev_mode=yes",
			fmt.Sprintf("optimize=%s", optimize),
		)
	}

	// Append C/C++ build flags.
	if len(b.SCons.CCFlags) > 0 {
		flags := fmt.Sprintf(`CCFLAGS="%s"`, strings.Join(b.SCons.CCFlags, " "))
		args = append(args, flags)
	}

	if len(b.SCons.CFlags) > 0 {
		flags := fmt.Sprintf(`CFLAGS="%s"`, strings.Join(b.SCons.CFlags, " "))
		args = append(args, flags)
	}

	if len(b.SCons.CXXFlags) > 0 {
		flags := fmt.Sprintf(`CXXFLAGS="%s"`, strings.Join(b.SCons.CXXFlags, " "))
		args = append(args, flags)
	}

	if len(b.SCons.LinkFlags) > 0 {
		flags := fmt.Sprintf(`LINKFLAGS="%s"`, strings.Join(b.SCons.LinkFlags, " "))
		args = append(args, flags)
	}

	// Append extra arguments.
	args = append(args, b.SCons.ExtraArgs...)

	// Attach the command with arguments to the action.
	cmd.Args = append(cmd.Args, scons.Command...)
	cmd.Args = append(cmd.Args, args...)

	return &cmd
}
